const QWIK_LOADER = "((e,t)=>{const n=\"__q_context__\",o=window,r=new Set,i=t=>e.querySelectorAll(t),s=(e,t,n=t.type)=>{i(\"[on\"+e+\"\\\\:\"+n+\"]\").forEach((o=>l(o,e,t,n)))},a=(e,t)=>new CustomEvent(e,{detail:t}),c=(t,n)=>(t=t.closest(\"[q\\\\:container]\"),new URL(n,new URL(t.getAttribute(\"q:base\"),e.baseURI))),l=async(t,o,r,i=r.type)=>{const s=\"on\"+o+\":\"+i;t.hasAttribute(\"preventdefault:\"+i)&&r.preventDefault();const a=t._qc_,l=null==a?void 0:a.li.filter((e=>e[0]===s));if(l&&l.length>0){for(const e of l)await e[1].getFn([t,r],(()=>t.isConnected))(r,t);return}const d=t.getAttribute(s);if(d)for(const o of d.split(\"\\n\")){const i=c(t,o),s=b(i),a=performance.now(),l=u(await import(i.href.split(\"#\")[0]),s),d=e[n];if(t.isConnected)try{e[n]=[t,r,i],f(\"qsymbol\",{symbol:s,element:t,reqTime:a}),await l(r,t)}finally{e[n]=d}}},f=(t,n)=>{e.dispatchEvent(a(t,n))},u=(e,t)=>{if(t in e)return e[t];for(const n of Object.values(e))if(\"object\"==typeof n&&n&&t in n)return n[t]},b=e=>e.hash.replace(/^#?([^?[|]*).*$/,\"$1\")||\"default\",d=e=>e.replace(/([A-Z])/g,(e=>\"-\"+e.toLowerCase())),p=async e=>{let t=d(e.type),n=e.target;for(s(\"-document\",e,t);n&&n.getAttribute;)await l(n,\"\",e,t),n=e.bubbles&&!0!==e.cancelBubble?n.parentElement:null},v=e=>{s(\"-window\",e,d(e.type))},w=()=>{var n;const s=e.readyState;if(!t&&(\"interactive\"==s||\"complete\"==s)&&(t=1,f(\"qinit\"),(null!=(n=o.requestIdleCallback)?n:o.setTimeout).bind(o)((()=>f(\"qidle\"))),r.has(\"qvisible\"))){const e=i(\"[on\\\\:qvisible]\"),t=new IntersectionObserver((e=>{for(const n of e)n.isIntersecting&&(t.unobserve(n.target),l(n.target,\"\",a(\"qvisible\",n)))}));e.forEach((e=>t.observe(e)))}},q=(e,t,n,o=!1)=>e.addEventListener(t,n,{capture:o}),y=t=>{for(const n of t)r.has(n)||(q(e,n,p,!0),q(o,n,v),r.add(n))};if(!e.qR){const t=o.qwikevents;Array.isArray(t)&&y(t),o.qwikevents={push:(...e)=>y(e)},q(e,\"readystatechange\",w),w()}})(document);";
const QWIK_LOADER_DEBUG = "(() => {\n    ((doc, hasInitialized) => {\n        const win = window;\n        const events =  new Set;\n        const querySelectorAll = query => doc.querySelectorAll(query);\n        const broadcast = (infix, ev, type = ev.type) => {\n            querySelectorAll(\"[on\" + infix + \"\\\\:\" + type + \"]\").forEach((target => dispatch(target, infix, ev, type)));\n        };\n        const createEvent = (eventName, detail) => new CustomEvent(eventName, {\n            detail: detail\n        });\n        const qrlResolver = (element, qrl) => {\n            element = element.closest(\"[q\\\\:container]\");\n            return new URL(qrl, new URL(element.getAttribute(\"q:base\"), doc.baseURI));\n        };\n        const dispatch = async (element, onPrefix, ev, eventName = ev.type) => {\n            const attrName = \"on\" + onPrefix + \":\" + eventName;\n            element.hasAttribute(\"preventdefault:\" + eventName) && ev.preventDefault();\n            const ctx = element._qc_;\n            const qrls = null == ctx ? void 0 : ctx.li.filter((li => li[0] === attrName));\n            if (qrls && qrls.length > 0) {\n                for (const q of qrls) {\n                    await q[1].getFn([ element, ev ], (() => element.isConnected))(ev, element);\n                }\n                return;\n            }\n            const attrValue = element.getAttribute(attrName);\n            if (attrValue) {\n                for (const qrl of attrValue.split(\"\\n\")) {\n                    const url = qrlResolver(element, qrl);\n                    const symbolName = getSymbolName(url);\n                    const reqTime = performance.now();\n                    const handler = findSymbol(await import(url.href.split(\"#\")[0]), symbolName);\n                    const previousCtx = doc.__q_context__;\n                    if (element.isConnected) {\n                        try {\n                            doc.__q_context__ = [ element, ev, url ];\n                            emitEvent(\"qsymbol\", {\n                                symbol: symbolName,\n                                element: element,\n                                reqTime: reqTime\n                            });\n                            await handler(ev, element);\n                        } finally {\n                            doc.__q_context__ = previousCtx;\n                        }\n                    }\n                }\n            }\n        };\n        const emitEvent = (eventName, detail) => {\n            doc.dispatchEvent(createEvent(eventName, detail));\n        };\n        const findSymbol = (module, symbol) => {\n            if (symbol in module) {\n                return module[symbol];\n            }\n            for (const v of Object.values(module)) {\n                if (\"object\" == typeof v && v && symbol in v) {\n                    return v[symbol];\n                }\n            }\n        };\n        const getSymbolName = url => url.hash.replace(/^#?([^?[|]*).*$/, \"$1\") || \"default\";\n        const camelToKebab = str => str.replace(/([A-Z])/g, (a => \"-\" + a.toLowerCase()));\n        const processDocumentEvent = async ev => {\n            let type = camelToKebab(ev.type);\n            let element = ev.target;\n            broadcast(\"-document\", ev, type);\n            while (element && element.getAttribute) {\n                await dispatch(element, \"\", ev, type);\n                element = ev.bubbles && !0 !== ev.cancelBubble ? element.parentElement : null;\n            }\n        };\n        const processWindowEvent = ev => {\n            broadcast(\"-window\", ev, camelToKebab(ev.type));\n        };\n        const processReadyStateChange = () => {\n            var _a;\n            const readyState = doc.readyState;\n            if (!hasInitialized && (\"interactive\" == readyState || \"complete\" == readyState)) {\n                hasInitialized = 1;\n                emitEvent(\"qinit\");\n                (null != (_a = win.requestIdleCallback) ? _a : win.setTimeout).bind(win)((() => emitEvent(\"qidle\")));\n                if (events.has(\"qvisible\")) {\n                    const results = querySelectorAll(\"[on\\\\:qvisible]\");\n                    const observer = new IntersectionObserver((entries => {\n                        for (const entry of entries) {\n                            if (entry.isIntersecting) {\n                                observer.unobserve(entry.target);\n                                dispatch(entry.target, \"\", createEvent(\"qvisible\", entry));\n                            }\n                        }\n                    }));\n                    results.forEach((el => observer.observe(el)));\n                }\n            }\n        };\n        const addEventListener = (el, eventName, handler, capture = !1) => el.addEventListener(eventName, handler, {\n            capture: capture\n        });\n        const push = eventNames => {\n            for (const eventName of eventNames) {\n                if (!events.has(eventName)) {\n                    addEventListener(doc, eventName, processDocumentEvent, !0);\n                    addEventListener(win, eventName, processWindowEvent);\n                    events.add(eventName);\n                }\n            }\n        };\n        if (!doc.qR) {\n            const qwikevents = win.qwikevents;\n            Array.isArray(qwikevents) && push(qwikevents);\n            win.qwikevents = {\n                push: (...e) => push(e)\n            };\n            addEventListener(doc, \"readystatechange\", processReadyStateChange);\n            processReadyStateChange();\n        }\n    })(document);\n})();";
exports.QWIK_LOADER = QWIK_LOADER;
exports.QWIK_LOADER_DEBUG = QWIK_LOADER_DEBUG;
